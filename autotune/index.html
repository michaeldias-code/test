<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Autotune Pro</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 20px;
    }
    
    .container {
      background: white;
      border-radius: 20px;
      padding: 40px;
      max-width: 600px;
      width: 100%;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
    }
    
    h1 {
      color: #667eea;
      margin-bottom: 10px;
      font-size: 32px;
    }
    
    .subtitle {
      color: #666;
      margin-bottom: 30px;
      font-size: 14px;
    }
    
    .upload-area {
      border: 3px dashed #667eea;
      border-radius: 15px;
      padding: 40px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s;
      margin-bottom: 30px;
    }
    
    .upload-area:hover {
      background: #f8f9ff;
      border-color: #764ba2;
    }
    
    .upload-area.has-file {
      border-color: #48bb78;
      background: #f0fff4;
    }
    
    .upload-area.error {
      border-color: #f56565;
      background: #fff5f5;
    }
    
    input[type="file"] {
      display: none;
    }
    
    .upload-icon {
      font-size: 48px;
      margin-bottom: 15px;
    }
    
    .settings {
      margin-bottom: 30px;
    }
    
    .setting-group {
      margin-bottom: 20px;
    }
    
    label {
      display: block;
      margin-bottom: 8px;
      color: #333;
      font-weight: 600;
      font-size: 14px;
    }
    
    input[type="range"] {
      width: 100%;
      height: 8px;
      border-radius: 5px;
      background: #e2e8f0;
      outline: none;
      -webkit-appearance: none;
    }
    
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #667eea;
      cursor: pointer;
    }
    
    input[type="range"]::-moz-range-thumb {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #667eea;
      cursor: pointer;
      border: none;
    }
    
    select {
      width: 100%;
      padding: 12px;
      border: 2px solid #e2e8f0;
      border-radius: 10px;
      font-size: 14px;
      background: white;
      cursor: pointer;
      transition: all 0.3s;
    }
    
    select:focus {
      outline: none;
      border-color: #667eea;
    }
    
    .value-display {
      display: inline-block;
      margin-left: 10px;
      color: #667eea;
      font-weight: bold;
    }
    
    button {
      width: 100%;
      padding: 15px;
      border: none;
      border-radius: 10px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
      margin-bottom: 10px;
    }
    
    .btn-process {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }
    
    .btn-process:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
    }
    
    .btn-process:disabled {
      background: #cbd5e0;
      cursor: not-allowed;
      transform: none;
    }
    
    .btn-download {
      background: #48bb78;
      color: white;
      display: none;
    }
    
    .btn-download:hover {
      background: #38a169;
      transform: translateY(-2px);
      box-shadow: 0 10px 20px rgba(72, 187, 120, 0.3);
    }
    
    .progress {
      margin-top: 20px;
      padding: 15px;
      background: #f7fafc;
      border-radius: 10px;
      text-align: center;
      display: none;
    }
    
    .progress-bar {
      width: 100%;
      height: 8px;
      background: #e2e8f0;
      border-radius: 5px;
      overflow: hidden;
      margin-top: 10px;
    }
    
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
      width: 0%;
      transition: width 0.3s;
    }
    
    .info {
      background: #ebf8ff;
      padding: 15px;
      border-radius: 10px;
      margin-top: 20px;
      font-size: 13px;
      color: #2c5282;
      line-height: 1.6;
    }
    
    .error-message {
      background: #fff5f5;
      border: 2px solid #f56565;
      padding: 15px;
      border-radius: 10px;
      margin-top: 20px;
      color: #c53030;
      display: none;
    }
    
    .audio-info {
      background: #f0fff4;
      border: 2px solid #48bb78;
      padding: 12px;
      border-radius: 10px;
      margin-bottom: 20px;
      font-size: 13px;
      display: none;
    }
    
    .audio-info strong {
      color: #2f855a;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üéµ Autotune Pro</h1>
    <p class="subtitle">Corrija a afina√ß√£o da sua voz automaticamente</p>
    
    <div class="upload-area" id="uploadArea">
      <div class="upload-icon">üìÅ</div>
      <p><strong>Clique para selecionar</strong> ou arraste um arquivo de √°udio</p>
      <p style="font-size: 12px; color: #999; margin-top: 5px;">Recomendado: WAV ou MP3 de alta qualidade</p>
      <input type="file" id="audioFile" accept="audio/*">
    </div>
    
    <div class="error-message" id="errorMessage"></div>
    
    <div class="audio-info" id="audioInfo"></div>
    
    <div class="settings">
      <div class="setting-group">
        <label>
          Intensidade do Autotune
          <span class="value-display" id="strengthValue">80%</span>
        </label>
        <input type="range" id="strength" min="0" max="100" value="80">
        <p style="font-size: 12px; color: #666; margin-top: 5px;">
          0% = natural | 100% = rob√≥tico (efeito T-Pain)
        </p>
      </div>
      
      <div class="setting-group">
        <label>Escala Musical</label>
        <select id="scale">
          <option value="chromatic">Crom√°tica (todas as notas)</option>
          <option value="major">Maior (D√≥ maior)</option>
          <option value="minor">Menor (L√° menor)</option>
          <option value="pentatonic">Pentat√¥nica</option>
        </select>
      </div>
    </div>
    
    <button class="btn-process" id="processBtn" disabled>
      Processar √Åudio
    </button>
    
    <button class="btn-download" id="downloadBtn">
      ‚¨áÔ∏è Baixar √Åudio Processado
    </button>
    
    <div class="progress" id="progress">
      <p id="progressText">Processando...</p>
      <div class="progress-bar">
        <div class="progress-fill" id="progressFill"></div>
      </div>
    </div>
    
    <div class="info">
      <strong>üí° Dica:</strong> Para melhor resultado, use √°udio WAV ou MP3 com voz limpa e sem muito ru√≠do de fundo. 
      Se o M4A n√£o funcionar, converta para WAV ou MP3 antes de enviar.
    </div>
  </div>

  <script>
    const uploadArea = document.getElementById('uploadArea');
    const fileInput = document.getElementById('audioFile');
    const processBtn = document.getElementById('processBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const strengthSlider = document.getElementById('strength');
    const strengthValue = document.getElementById('strengthValue');
    const scaleSelect = document.getElementById('scale');
    const progress = document.getElementById('progress');
    const progressText = document.getElementById('progressText');
    const progressFill = document.getElementById('progressFill');
    const errorMessage = document.getElementById('errorMessage');
    const audioInfo = document.getElementById('audioInfo');

    let audioBuffer = null;
    let processedBuffer = null;
    let audioContext = null;

    // Escalas musicais (semitons relativos a C)
    const scales = {
      chromatic: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
      major: [0, 2, 4, 5, 7, 9, 11],
      minor: [0, 2, 3, 5, 7, 8, 10],
      pentatonic: [0, 2, 4, 7, 9]
    };

    // Upload de arquivo
    uploadArea.addEventListener('click', () => fileInput.click());
    
    uploadArea.addEventListener('dragover', (e) => {
      e.preventDefault();
      uploadArea.style.background = '#f8f9ff';
    });
    
    uploadArea.addEventListener('dragleave', () => {
      uploadArea.style.background = '';
    });
    
    uploadArea.addEventListener('drop', (e) => {
      e.preventDefault();
      uploadArea.style.background = '';
      if (e.dataTransfer.files.length) {
        fileInput.files = e.dataTransfer.files;
        handleFileSelect();
      }
    });

    fileInput.addEventListener('change', handleFileSelect);

    async function handleFileSelect() {
      const file = fileInput.files[0];
      if (!file) return;

      hideError();
      audioInfo.style.display = 'none';
      uploadArea.classList.remove('has-file', 'error');
      processBtn.disabled = true;
      downloadBtn.style.display = 'none';

      // Mostrar que est√° carregando
      uploadArea.querySelector('p').innerHTML = `<strong>‚è≥ Carregando ${file.name}...</strong>`;

      try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        // Tentar carregar o √°udio
        const arrayBuffer = await file.arrayBuffer();
        
        // Tentar decodificar
        try {
          audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
          
          // Sucesso!
          uploadArea.classList.add('has-file');
          uploadArea.querySelector('p').innerHTML = `<strong>‚úì ${file.name}</strong><br><span style="font-size: 12px;">Pronto para processar</span>`;
          processBtn.disabled = false;
          
          // Mostrar informa√ß√µes do √°udio
          showAudioInfo(audioBuffer, file);
          
        } catch (decodeError) {
          // Erro ao decodificar - formato n√£o suportado
          throw new Error('Formato de √°udio n√£o suportado pelo navegador. Use WAV ou MP3 de alta qualidade.');
        }
        
      } catch (error) {
        uploadArea.classList.add('error');
        uploadArea.querySelector('p').innerHTML = `<strong>‚ùå Erro ao carregar</strong>`;
        showError(error.message);
      }
    }

    function showAudioInfo(buffer, file) {
      const duration = buffer.duration.toFixed(1);
      const sampleRate = buffer.sampleRate;
      const channels = buffer.numberOfChannels;
      const fileSize = (file.size / 1024 / 1024).toFixed(2);
      
      audioInfo.innerHTML = `
        <strong>Informa√ß√µes do √°udio:</strong><br>
        Dura√ß√£o: ${duration}s | Taxa: ${sampleRate}Hz | Canais: ${channels} | Tamanho: ${fileSize}MB
      `;
      audioInfo.style.display = 'block';
    }

    function showError(message) {
      errorMessage.textContent = '‚ùå ' + message;
      errorMessage.style.display = 'block';
      
      // Sugest√µes baseadas no erro
      if (message.includes('n√£o suportado')) {
        errorMessage.innerHTML += '<br><br><strong>Solu√ß√£o:</strong> Converta o arquivo para WAV ou MP3 usando um app como:<br>‚Ä¢ <a href="https://online-audio-converter.com" target="_blank" style="color: #c53030;">Online Audio Converter</a><br>‚Ä¢ Media Converter (Android)<br>‚Ä¢ The Audio Converter (iOS)';
      }
    }

    function hideError() {
      errorMessage.style.display = 'none';
    }

    strengthSlider.addEventListener('input', (e) => {
      strengthValue.textContent = e.target.value + '%';
    });

    processBtn.addEventListener('click', processAudio);

    async function processAudio() {
      if (!audioBuffer) return;

      processBtn.disabled = true;
      progress.style.display = 'block';
      downloadBtn.style.display = 'none';
      hideError();
      
      const strength = strengthSlider.value / 100;
      const selectedScale = scales[scaleSelect.value];

      try {
        // Processar cada canal
        const channels = [];
        for (let ch = 0; ch < audioBuffer.numberOfChannels; ch++) {
          updateProgress(0, `Processando canal ${ch + 1}/${audioBuffer.numberOfChannels}...`);
          const channelData = audioBuffer.getChannelData(ch);
          const processed = await autotune(channelData, audioBuffer.sampleRate, strength, selectedScale);
          channels.push(processed);
        }

        // Criar buffer de sa√≠da
        processedBuffer = audioContext.createBuffer(
          channels.length,
          channels[0].length,
          audioBuffer.sampleRate
        );

        channels.forEach((channel, i) => {
          processedBuffer.copyToChannel(channel, i);
        });

        updateProgress(100, 'Conclu√≠do!');
        setTimeout(() => {
          progress.style.display = 'none';
          downloadBtn.style.display = 'block';
          processBtn.disabled = false;
        }, 1000);

      } catch (error) {
        showError('Erro ao processar: ' + error.message);
        progress.style.display = 'none';
        processBtn.disabled = false;
      }
    }

    async function autotune(buffer, sampleRate, strength, scale) {
      const windowSize = 4096; // Janela maior = melhor detec√ß√£o
      const hopSize = 1024;
      const output = new Float32Array(buffer.length);
      const overlapAdd = new Float32Array(buffer.length); // Para contagem de sobreposi√ß√£o
      
      // Processar em janelas com yield para n√£o travar
      const totalWindows = Math.floor((buffer.length - windowSize) / hopSize);
      let windowCount = 0;
      
      for (let i = 0; i < buffer.length - windowSize; i += hopSize) {
        // Criar janela
        const window = new Float32Array(windowSize);
        for (let j = 0; j < windowSize; j++) {
          window[j] = buffer[i + j];
        }
        
        // Detectar pitch
        const pitch = detectPitch(window, sampleRate);
        
        if (pitch > 0) {
          // Encontrar nota mais pr√≥xima na escala
          const targetPitch = closestNoteInScale(pitch, scale);
          
          // Calcular corre√ß√£o - aplicar strength como fator de "velocidade"
          const ratio = targetPitch / pitch;
          const finalRatio = 1 + (ratio - 1) * strength;
          
          // Phase vocoder simplificado para melhor qualidade
          const fftSize = windowSize;
          const shiftedWindow = phaseVocoder(window, finalRatio, fftSize);
          
          // Aplicar janela de Hann e adicionar
          for (let j = 0; j < shiftedWindow.length && i + j < output.length; j++) {
            const hannWindow = 0.5 * (1 - Math.cos(2 * Math.PI * j / windowSize));
            output[i + j] += shiftedWindow[j] * hannWindow;
            overlapAdd[i + j] += hannWindow;
          }
        } else {
          // Sem pitch detectado, copiar original com janela
          for (let j = 0; j < windowSize && i + j < output.length; j++) {
            const hannWindow = 0.5 * (1 - Math.cos(2 * Math.PI * j / windowSize));
            output[i + j] += window[j] * hannWindow;
            overlapAdd[i + j] += hannWindow;
          }
        }
        
        // Atualizar progresso e dar chance ao navegador respirar
        windowCount++;
        if (windowCount % 50 === 0) {
          updateProgress((windowCount / totalWindows) * 100);
          await new Promise(resolve => setTimeout(resolve, 0));
        }
      }
      
      // Normalizar pela sobreposi√ß√£o
      for (let i = 0; i < output.length; i++) {
        if (overlapAdd[i] > 0) {
          output[i] /= overlapAdd[i];
        }
      }
      
      // Normalizar amplitude
      let max = 0;
      for (let i = 0; i < output.length; i++) {
        const abs = Math.abs(output[i]);
        if (abs > max) max = abs;
      }
      
      if (max > 0) {
        const normFactor = 0.95 / max; // Deixa margem para evitar clipping
        for (let i = 0; i < output.length; i++) {
          output[i] *= normFactor;
        }
      }
      
      return output;
    }
    
    function phaseVocoder(buffer, ratio, fftSize) {
      // Implementa√ß√£o simplificada de phase vocoder
      // Para produ√ß√£o seria ideal usar FFT, mas aqui uso interpola√ß√£o de alta qualidade
      const output = new Float32Array(buffer.length);
      
      for (let i = 0; i < output.length; i++) {
        const sourcePos = i / ratio;
        
        // Interpola√ß√£o c√∫bica (melhor que linear)
        const i0 = Math.floor(sourcePos) - 1;
        const i1 = Math.floor(sourcePos);
        const i2 = Math.floor(sourcePos) + 1;
        const i3 = Math.floor(sourcePos) + 2;
        const frac = sourcePos - Math.floor(sourcePos);
        
        // Garantir limites
        const s0 = (i0 >= 0 && i0 < buffer.length) ? buffer[i0] : 0;
        const s1 = (i1 >= 0 && i1 < buffer.length) ? buffer[i1] : 0;
        const s2 = (i2 >= 0 && i2 < buffer.length) ? buffer[i2] : 0;
        const s3 = (i3 >= 0 && i3 < buffer.length) ? buffer[i3] : 0;
        
        // Interpola√ß√£o c√∫bica de Catmull-Rom
        const a0 = -0.5 * s0 + 1.5 * s1 - 1.5 * s2 + 0.5 * s3;
        const a1 = s0 - 2.5 * s1 + 2 * s2 - 0.5 * s3;
        const a2 = -0.5 * s0 + 0.5 * s2;
        const a3 = s1;
        
        output[i] = a0 * frac * frac * frac + a1 * frac * frac + a2 * frac + a3;
      }
      
      return output;
    }

    function detectPitch(buffer, sampleRate) {
      const SIZE = buffer.length;
      let rms = 0;

      // Calcular RMS
      for (let i = 0; i < SIZE; i++) {
        rms += buffer[i] * buffer[i];
      }
      rms = Math.sqrt(rms / SIZE);
      
      if (rms < 0.005) return -1; // Sil√™ncio

      // Autocorrela√ß√£o usando YIN algorithm (mais preciso)
      const threshold = 0.1;
      const minLag = Math.floor(sampleRate / 1000); // 1000 Hz max
      const maxLag = Math.floor(sampleRate / 80);   // 80 Hz min
      
      // Difference function
      const diff = new Float32Array(maxLag);
      for (let lag = 0; lag < maxLag; lag++) {
        let sum = 0;
        for (let i = 0; i < SIZE - maxLag; i++) {
          const delta = buffer[i] - buffer[i + lag];
          sum += delta * delta;
        }
        diff[lag] = sum;
      }
      
      // Cumulative mean normalized difference
      const cmndf = new Float32Array(maxLag);
      cmndf[0] = 1;
      let runningSum = 0;
      
      for (let lag = 1; lag < maxLag; lag++) {
        runningSum += diff[lag];
        cmndf[lag] = diff[lag] / (runningSum / lag);
      }
      
      // Find first minimum below threshold
      let bestLag = -1;
      for (let lag = minLag; lag < maxLag; lag++) {
        if (cmndf[lag] < threshold) {
          // Parabolic interpolation for sub-sample accuracy
          if (lag > 0 && lag < maxLag - 1) {
            const s0 = cmndf[lag - 1];
            const s1 = cmndf[lag];
            const s2 = cmndf[lag + 1];
            const adjustment = (s2 - s0) / (2 * (2 * s1 - s2 - s0));
            bestLag = lag + adjustment;
          } else {
            bestLag = lag;
          }
          break;
        }
      }
      
      if (bestLag > 0) {
        const pitch = sampleRate / bestLag;
        if (pitch >= 80 && pitch <= 1000) {
          return pitch;
        }
      }
      
      return -1;
    }

    function closestNoteInScale(freq, scale) {
      const A4 = 440;
      const C0 = A4 * Math.pow(2, -4.75); // C0 frequency
      
      // Converter frequ√™ncia para semitons de C0
      const halfSteps = 12 * Math.log2(freq / C0);
      const octave = Math.floor(halfSteps / 12);
      const noteInOctave = Math.round(halfSteps % 12);
      
      // Encontrar nota mais pr√≥xima na escala
      let closest = scale[0];
      let minDist = Math.abs(noteInOctave - scale[0]);
      
      for (let note of scale) {
        const dist = Math.abs(noteInOctave - note);
        if (dist < minDist) {
          minDist = dist;
          closest = note;
        }
      }
      
      // Converter de volta para frequ√™ncia
      const targetHalfSteps = octave * 12 + closest;
      return C0 * Math.pow(2, targetHalfSteps / 12);
    }

    function pitchShift(buffer, ratio) {
      // Removida - agora inline no autotune
      return buffer;
    }

    function updateProgress(percent, text) {
      progressFill.style.width = percent + '%';
      if (text) progressText.textContent = text;
    }

    downloadBtn.addEventListener('click', () => {
      if (!processedBuffer) return;
      
      const wav = bufferToWave(processedBuffer);
      const blob = new Blob([wav], { type: 'audio/wav' });
      const url = URL.createObjectURL(blob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = 'autotune_' + Date.now() + '.wav';
      a.click();
      
      URL.revokeObjectURL(url);
    });

    function bufferToWave(buffer) {
      const numChannels = buffer.numberOfChannels;
      const sampleRate = buffer.sampleRate;
      const format = 1; // PCM
      const bitDepth = 16;
      
      const bytesPerSample = bitDepth / 8;
      const blockAlign = numChannels * bytesPerSample;
      
      const data = [];
      for (let i = 0; i < buffer.length; i++) {
        for (let ch = 0; ch < numChannels; ch++) {
          let sample = buffer.getChannelData(ch)[i];
          sample = Math.max(-1, Math.min(1, sample));
          sample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
          data.push(sample);
        }
      }
      
      const dataSize = data.length * bytesPerSample;
      const view = new DataView(new ArrayBuffer(44 + dataSize));
      
      // RIFF header
      writeString(view, 0, 'RIFF');
      view.setUint32(4, 36 + dataSize, true);
      writeString(view, 8, 'WAVE');
      
      // fmt chunk
      writeString(view, 12, 'fmt ');
      view.setUint32(16, 16, true);
      view.setUint16(20, format, true);
      view.setUint16(22, numChannels, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, sampleRate * blockAlign, true);
      view.setUint16(32, blockAlign, true);
      view.setUint16(34, bitDepth, true);
      
      // data chunk
      writeString(view, 36, 'data');
      view.setUint32(40, dataSize, true);
      
      let offset = 44;
      for (let i = 0; i < data.length; i++) {
        view.setInt16(offset, data[i], true);
        offset += 2;
      }
      
      return view.buffer;
    }

    function writeString(view, offset, string) {
      for (let i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
      }
    }
  </script>
</body>
</html>
